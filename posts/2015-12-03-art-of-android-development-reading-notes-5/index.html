<!DOCTYPE html>
<html lang="cn">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
		<meta name="author" content="潇涧">
		<meta name="description" content="这里是描述">
		<meta name="generator" content="Hugo 0.67.0" />
		<title>《Android开发艺术探索》读书笔记 (5) 第5章 理解RemoteViews &middot; 技术文章分享</title>
		<link rel="shortcut icon" href="http://www.pocketpoetry.club/images/favicon.ico">
		<link rel="stylesheet" href="http://www.pocketpoetry.club/css/style.css">
		<link rel="stylesheet" href="http://www.pocketpoetry.club/css/highlight.css">

		
		<link rel="stylesheet" href="http://www.pocketpoetry.club/css/font-awesome.min.css">
		

		

		
	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='http://www.pocketpoetry.club/'> <span class="arrow">←</span>首页</a>
	
	<a href='http://www.pocketpoetry.club/posts'>归档</a>
	
	<a href='http://www.pocketpoetry.club/about'>关于</a>

	

	
</nav>


        <section id="wrapper" class="post">
            <article>
                <header>
                    <h1>
                        《Android开发艺术探索》读书笔记 (5) 第5章 理解RemoteViews
                    </h1>
                    <h2 class="headline">
                    Dec 1, 2015 00:00
                    · 4407 words
                    · 9 minute read
                      <span class="tags">
                      
                      
                          
                              <a href="http://www.pocketpoetry.club/tags/android">android</a>
                          
                      
                      
                      </span>
                    </h2>
                </header>
                
                <section id="post-body">
                    <p>《Android开发艺术探索》读书笔记 (5) 第5章 理解RemoteViews</p>
<h3 id="第5章-理解remoteviews">第5章 理解RemoteViews</h3>
<h4 id="51-remoteviews的应用">5.1 <code>RemoteViews</code>的应用</h4>
<p>(1)RemoteViews表示的是一个view结构，它可以在其他进程中显示。由于它在其他进程中显示，为了能够更新它的界面，RemoteViews提供了一组基础的操作用于跨进程更新它的界面。<br>
(2)RemoteViews主要用于通知栏通知和桌面小部件的开发，通知栏通知是通过<code>NotificationManager</code>的<code>notify</code>方法来实现的；桌面小部件是通过<code>AppWidgetProvider</code>来实现的，它本质上是一个广播(BroadcastReceiver)。这两者的界面都是运行在<code>SystemServer</code>进程中。<br>
(3)RemoteViews在Notification中的应用示例</p>
<pre><code>Notification notification = new Notification();
notification.icon = R.drawable.ic_launcher;
notification.tickerText = &quot;hello world&quot;;
notification.when = System.currentTimeMillis();
notification.flags = Notification.FLAG_AUTO_CANCEL;
Intent intent = new Intent(this, DemoActivity_1.class);
intent.putExtra(&quot;sid&quot;, &quot;&quot; + sId);
PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);

RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification);
remoteViews.setTextViewText(R.id.msg, &quot;chapter_5: &quot; + sId);//设置textview的显示文本
remoteViews.setImageViewResource(R.id.icon, R.drawable.icon1);
PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, DemoActivity_2.class), PendingIntent.FLAG_UPDATE_CURRENT);
remoteViews.setOnClickPendingIntent(R.id.open_activity2, openActivity2PendingIntent);//给图片添加点击事件
notification.contentView = remoteViews;
notification.contentIntent = pendingIntent;
NotificationManager manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
manager.notify(sId, notification);
</code></pre><p>(4)RemoteViews在桌面小部件中的应用<br>
1.定义小部件界面；<br>
2.定义小部件配置信息：其中<code>updatePeriodMillis</code>定义小工具的自动更新周期，单位为ms。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/widget&quot;
    android:minHeight=&quot;84dp&quot;
    android:minWidth=&quot;84dp&quot;
    android:updatePeriodMillis=&quot;86400000&quot; &gt;
&lt;/appwidget-provider&gt;
</code></pre><p>3.定义小部件的实现类：书中的示例实现了一个显示一张图片的小部件，每次点击小部件的时候图片就会旋转一周；</p>
<pre><code>public class MyAppWidgetProvider extends AppWidgetProvider {

    public static final String TAG = &quot;MyAppWidgetProvider&quot;;
    public static final String CLICK_ACTION = &quot;com.ryg.chapter_5.action.CLICK&quot;;

    public MyAppWidgetProvider() {
        super();
    }

    @Override
    public void onReceive(final Context context, Intent intent) {
        super.onReceive(context, intent);
        Log.i(TAG, &quot;onReceive : action = &quot; + intent.getAction());

        // 这里判断是自己的action，做自己的事情，比如小工具被点击了要干啥，这里是做一个动画效果
        if (intent.getAction().equals(CLICK_ACTION)) {
            Toast.makeText(context, &quot;clicked it&quot;, Toast.LENGTH_SHORT).show();

            new Thread(new Runnable() {
                @Override
                public void run() {
                    Bitmap srcbBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.icon1);
                    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
                    for (int i = 0; i &lt; 37; i++) {
                        float degree = (i * 10) % 360;
                        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);
                        remoteViews.setImageViewBitmap(R.id.imageView1, rotateBitmap(context, srcbBitmap, degree));
                        Intent intentClick = new Intent();
                        intentClick.setAction(CLICK_ACTION);
                        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0);
                        remoteViews.setOnClickPendingIntent(R.id.imageView1, pendingIntent);
                        appWidgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class),remoteViews);
                        SystemClock.sleep(30);
                    }
                }
            }).start();
        }
    }

    /**
     * 每次窗口小部件被点击更新都调用一次该方法
     */
    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        super.onUpdate(context, appWidgetManager, appWidgetIds);
        Log.i(TAG, &quot;onUpdate&quot;);

        final int counter = appWidgetIds.length;
        Log.i(TAG, &quot;counter = &quot; + counter);
        for (int i = 0; i &lt; counter; i++) {
            int appWidgetId = appWidgetIds[i];
            onWidgetUpdate(context, appWidgetManager, appWidgetId);
        }
    }

    /**
     * 窗口小部件更新
     */
    private void onWidgetUpdate(Context context, AppWidgetManager appWidgeManger, int appWidgetId) {
        Log.i(TAG, &quot;appWidgetId = &quot; + appWidgetId);
        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);

        // &quot;窗口小部件&quot;点击事件发送的Intent广播
        Intent intentClick = new Intent();
        intentClick.setAction(CLICK_ACTION);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0);
        remoteViews.setOnClickPendingIntent(R.id.imageView1, pendingIntent);
        appWidgeManger.updateAppWidget(appWidgetId, remoteViews);
    }

    private Bitmap rotateBitmap(Context context, Bitmap srcbBitmap, float degree) {
        Matrix matrix = new Matrix();
        matrix.reset();
        matrix.setRotate(degree);
        return Bitmap.createBitmap(srcbBitmap, 0, 0, srcbBitmap.getWidth(), srcbBitmap.getHeight(), matrix, true);
    }
}
</code></pre><p>4.在AndroidManifest.xml文件中声明小部件<br>
下面的示例中包含了两个action，第一个action用于识别小部件的单击行为，而第二个action是作为小部件必须存在的action <code>android.appwidget.action.APPWIDGET_UPDATE</code>，如果不加那么就无法显示小部件。</p>
<pre><code>&lt;receiver android:name=&quot;.MyAppWidgetProvider&quot; &gt;
    &lt;meta-data
        android:name=&quot;android.appwidget.provider&quot;
        android:resource=&quot;@xml/appwidget_provider_info&quot; &gt;
    &lt;/meta-data&gt;

    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.ryg.chapter_5.action.CLICK&quot; /&gt;
        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><p>(5)AppWidgetProvider会自动根据广播的action通过<code>onReceive</code>方法来自动分发广播，也就是调用下面不同的方法：<br>
<code>onEnable</code>：当小部件<strong>第一次</strong>添加到桌面时调用，小部件可以添加多次但是只在第一次添加的时候调用；<br>
<code>onUpdate</code>：小部件被添加时或者每次小部件更新时都会调用一次该方法，每个周期小部件都会自动更新一次；<br>
<code>onDeleted</code>：每删除一次小部件就调用一次；<br>
<code>onDisabled</code>：当<strong>最后一个</strong>该类型的小部件被删除时调用该方法；<br>
<code>onReceive</code>：这是广播内置的方法，用于分发具体的事件给其他方法，所以该方法一般要调用<code>super.onReceive(context, intent);</code> 如果自定义了其他action的广播，就可以在调用了父类方法之后进行判断，如上面代码所示。<br>
(6)<code>PendingIntent</code>表示一种处于Pending状态的Intent，pending表示的是即将发生的意思，它是在将来的某个不确定的时刻放生，而Intent是立刻发生。<br>
(7)PendingIntent支持三种待定意图：启动Activity(getActivity)，启动Service(getService)，发送广播(getBroadcast)。<br>
<code>PendingIntent.getActivity(Context context, in requestCode, Intent intent, int flags)</code>
获得一个PendingIntent，当待定意图发生时，效果相当于Context.startActivity(intent)。<br>
第二个参数<code>requestCode</code>是PendingIntent发送方的请求码，多数情况下设为0即可，另外requestCode会影响到flags的效果。<br>
<strong>PendingIntent的匹配规则：如果两个PendingIntent内部的Intent相同，并且requestCode也相同，那么这两个PendingIntent就是相同的。</strong><br>
<strong>Intent的匹配规则：如果两个Intent的ComponentName和intent-filter都相同，那么这两个Intent就是相同的，Extras不参与Intent的匹配过程。</strong><br>
第四个参数flags常见的类型有：<code>FLAG_ONE_SHOT</code>、<code>FLAG_NO_CREATE</code>、<code>FLAG_CANCEL_CURRENT</code>、<code>FLAG_UPDATE_CURRENT</code>。<br>
<code>FLAG_ONE_SHOT</code>：当前描述的PendingIntent只能被调用一次，然后它就会被自动cancel。如果后续还有相同的PendingIntent，那么它们的send方法就会调用失败。对于通知栏消息来说，如果采用这个flag，那么同类的通知只能使用一次，后续的通知单击后将无法打开。<br>
<code>FLAG_NO_CREATE</code>：当前描述的PendingIntent不会主动创建，如果当前PendingIntent之前不存在，那么getActivity、getService和getBroadcast方法会直接返回null，即获取PendingIntent失败。这个标志位使用很少。<br>
<code>FLAG_CANCEL_CURRENT</code>：当前描述的PendingIntent如果已经存在，那么它们都会被cancel，然后系统会创建一个新的PendingIntent。对于通知栏消息来说，那些被cancel的通知单击后将无法打开。<br>
<code>FLAG_UPDATE_CURRENT</code>：当前描述的PendingIntent如果已经存在，那么它们都会被更新，即它们的Intent中的Extras会被替换成最新的。</p>
<p>(8)分析<code>NotificationManager.nofify(id, notification)</code> [未测试，看着有点晕]<br>
1.如果参数id是常量，那么多次调用notify只能弹出一个通知，后续的通知会把前面的通知完全替代掉；<br>
2.如果参数id每次都不同，那么当PendingIntent不匹配的时候，不管采用何种标志位，这些通知之间不会相互干扰；<br>
3.如果参数id每次都不同，且PendingIntent匹配的时候，那就要看标志位：<br>
如果标志位是FLAG_ONE_SHOT，那么后续的通知中的PendingIntent会和第一条通知保持完全一致，包括其中的Extras，单击任何一条通知后，剩下的通知均无法再打开，当所有的通知都被清除后，会再次重复这个过程；<br>
如果标志位是FLAG_CANCEL_CURRENT，那么只有最新的通知可以打开，之前弹出的所有通知都无法打开；<br>
如果标志位是FLAG_UPDATE_CURRENT，那么之前弹出的通知中的PendingIntent会被更新，最终它们和最新的一条通知保持完全一致，包括其中的Extras，并且这些通知都是可以打开的。</p>
<h4 id="52-remoteviews的内部机制">5.2 RemoteViews的内部机制</h4>
<p>(1)RemoteViews的构造方法 <code>public RemoteViews(String packageName, int layoutId)</code>，第一个参数是当前应用的包名，第二个参数是待加载的布局文件。<br>
(2)RemoteViews只支持部分布局和View组件，下面列举的组件的子类是不支持的<br>
布局：<code>FrameLayout、LinearLayout、RelativeLayout、GridLayout</code><br>
组件：<code>Button、ImageButton、ImageView、TextView、ListView、GridView、ViewStub</code>等<br>
(3)RemoteViews提供了一系列的set方法完成view的设置，这是通过反射完成的调用的。<br>
例如方法<code>setInt(int viewId, String methodName, int value)</code>就是反射调用view对象的名称为methodName的方法，传入参数value，同样的还有<code>setBoolean</code>、<code>setLong</code>等。<br>
方法<code>setOnClickPendingIntent(int viewId, PendingIntent pi)</code>用来为view添加单击事件，事件类型只能为PendingIntent。<br>
(4)通知和小部件分别由<code>NotificationManager</code>和<code>AppWidgetManager</code>管理，而它们通过Binder分别和SystemServer进程中的<code>NotificationManagerService</code>和<code>AppWidgetManagerService</code>进行通信。所以，布局文件实际上是两个Service加载的，运行在SystemServer进程中。<br>
(5)RemoteViews实现了<code>Parcelable</code>接口，它会通过Binder传递到SystemServer进程，系统会根据RemoteViews中的包名信息获取到应用中的资源，从而完成布局文件的加载。<br>
(6)系统将view操作封装成<code>Action</code>对象，Action同样实现了Parcelable接口，通过Binder传递到SystemServer进程。远程进程通过RemoteViews的<code>apply</code>方法来进行view的更新操作，RemoteViews的apply方法内部则会去遍历所有的action对象并调用它们的apply方法来进行view的更新操作。<br>
这样做的好处是不需要定义大量的Binder接口，其次批量执行RemoteViews中的更新操作提高了程序性能。<br>
(7)RemoteViews的<code>apply</code>和<code>reapply</code>方法的区别：<code>apply</code>方法会加载布局并更新界面，而<code>reapply</code>方法则只会更新界面。<br>
(8)<code>setOnClickPendingIntent</code>、<code>setPendingIntentTemplate</code>和<code>setOnClickFillIntent</code>的区别<br>
<code>setOnClickPendingIntent</code>用于给普通的view添加点击事件，但是不能给集合(ListView和StackView)中的view设置点击事件，因为开销太大了。如果需要给ListView和StackView中的item添加点击事件，需要结合<code>setPendingIntentTemplate</code>和<code>setOnClickFillIntent</code>一起使用。</p>
<h4 id="53-remoteviews的意义">5.3 RemoteViews的意义</h4>
<p>RemoteViews的最大的意义是实现了跨进程的UI更新，这节作者实现了一个模拟通知栏效果的应用来演示跨进程的UI更新，<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_5/src/com/ryg/chapter_5/MainActivity.java">源码传送门</a>。</p>
<p>OK，本章结束，谢谢阅读。</p>
                </section>
            </article>

            

            

            

            <footer id="footer">
    
    <p class="small">
    
       © Copyright 2020 <i class="fa fa-heart" aria-hidden="true"></i> 潇涧
    
    </p>
    
    <p class="small">
        <a href="https://beian.miit.gov.cn">粤ICP备20027217号</a>
    </p>
</footer>

        </section>

        <script src="http://www.pocketpoetry.club/js/jquery-3.3.1.min.js"></script>
<script src="http://www.pocketpoetry.club/js/main.js"></script>
<script src="http://www.pocketpoetry.club/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>







    </body>
</html>
